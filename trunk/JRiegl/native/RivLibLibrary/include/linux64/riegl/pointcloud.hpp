// $Id: pointcloud.hpp 738 2013-01-31 15:45:25Z RS $

#ifndef POINTCLOUD_HPP
#define POINTCLOUD_HPP

//! \file pointcloud.hpp
//! The pointcloud extractor and helper classes.


#include <riegl/config.hpp>
#include <riegl/ridataspec.hpp>
#include <riegl/detail/clockcomp.hpp>
#include <riegl/compressed.hpp>

#include <string>
#include <ostream>
#include <vector>
#include <limits>

namespace scanlib {

//! geometric data and attributes of a point
/*! This class holds the geometric x,y,z coordinates of a measured
    point and its attributes such as amplitude and reflectance.
 */
class RIVLIB_API target
{
public:
    target()
    {
        vertex[0] = vertex[1] = vertex[2] = 0.0;
        echo_range = 0;
        time        = 0;
        amplitude   = 0;
        reflectance = 0;
        deviation   = 0;
        background_radiation = std::numeric_limits<float>::quiet_NaN();
        is_sw       = false;
        is_high_power   = false;
        is_rising_edge  = false;
        is_pps_locked   = false;
        facet       = 0;
    }

    //! x-y-z coordinates
    /*! Cartesian coordinates in scanners own coordinate system.
        vertex[i] = beam_origin[i] + echo_range * beam_direction[i]
     */
    float vertex[3];

    //! echo range in units of meter
    /*! The distance from the laser origin to the target. Note that this
        is not the same as sqrt(vertex[0]^2 + vertex[1]^2 + vertex[2]^2).
     */
    double echo_range;

    //! time stamp in [s]
    /*! The epoch (i.e. where time equals zero) depends on a flag
        that has to be supplied in the constructor of the pointcloud object.
     */
    double time;

    //! relative amplitude in [dB]
    /* This is the ratio of the received power to the power received at
       the detection limit expressed in dB.
     */
    float amplitude;

    //! relative reflectance in [dB]
    /*! This is the ratio of the received power to the power that would
        be received from a white diffuse target at the same distance
        expressed in dB. The reflectance represents a range independent
        property of the target.  The surface normal of this target is assumed
        to be in parallel to the laser beam direction.
     */
    float reflectance;

    //! a measure of pulse shape distortion
    /*! A larger value for deviation indicates larger distortion.
      */
    float deviation;

    //! a measure of background radiation
    /*! A measure of background radiation. This information is optional.
        For instruments that do not deliver this value, the field is set
        to NaN.
     */
    float background_radiation;

    //! INTERNAL ONLY
    bool is_sw;             // generated by software full wave analysis

    //! INTERNAL ONLY
    bool is_high_power;     // high power channel flag

    //! INTERNAL ONLY
    bool is_rising_edge;    // edge flag

    //! time is a valid pps time
    bool is_pps_locked;

    //! INTERNAL ONLY
    unsigned facet;   // facet number
};

//!\brief pointcloud class
//!\details The pointcloud class combines several (undocumented) raw basic
//! packets into meaningful XYZ data with calibration already applied.
//! This makes the pointcloud class the main access point to data for client
//! applications. The class provides several virtual functions that the
//! client application is expected to override.
//! For every laser echo discovered in the raw data stream from the scanning
//! device an invocation of the on_echo_transformed is done. The function
//! provides as a parameter the type of echo. Each echo unambiguously belongs
//! to one of the possible classes of type echo_type. Please note that for
//! specifying all echoes that are farthest away you need to look for both
//! single _and_ last echoes. Similar reasoning is for closest echoes. I.e.
//! specifying only last will give you the echo points that are farthest away
//! but only if they are part of multi-return.
//! The time reference for the time stamps are user selectable. PPS time stamps
//! from a GPS receiver or internal time of the scanner device can be
//! choosen.
//! The point data is accesible through the targets member variable. This
//! variable is an array that always holds all echoes that belong to the
//! same laser shot. The echo that belongs to the current call to
//! on_echo_transformed is always accesible by means of the variable
//! target_count. I.e to access the top of the array specify
//! targets[target_count-1]. This design makes it possible for the client
//! application to either act on each echo separately or evaluate all
//! echoes that belong to a laser shot at once when the last echo for this
//! shot is seen. The targets array is reset to empty with each new laser shot.
class RIVLIB_API pointcloud
    //:  virtual public basic_packets
    : public compressed_packets
{
public:
    //! the echo type classifications, each echo belongs to exactly one class
    typedef enum { single, first, interior, last, none } echo_type;

    //! the value of PI
    static const double pi;

    //! constructor
    //!\param sync_to_pps_ use external time reference for time
    pointcloud(bool sync_to_pps_ = false);

    //! constructor
    //!\param out write pointcloud data in ASCII to a stream
    //!\param sync_to_pps_ use external time reference for time
    pointcloud(std::ostream& out, bool sync_to_pps_ = false);
    virtual ~pointcloud();

    //! override the default rangegate of the sensor
    //!\param zone select the mta zone. (if all parameters are zero, select sensor default)
    //!\param near if zone=0 specifies the closer end of the rangegate
    //!\param far if zone=0 specifies the farthmost end of the rangegate
    void set_rangegate(unsigned zone = 0, double near = 0, double far = 0);

    //! INTERNAL ONLY
    void set_notch_filter(float range_min, float range_max, float amplitude_max);

    //! number of facets (instrument constant)
    unsigned num_facets;

    //! flag indicating the time reference to use
    bool sync_to_pps;
    //! the timestamp of the current shot in sec (ref. depends on sync_to_pps)
    double time;
    //! time of start of range gate of current shot in sec
    double time_sorg;
    //! beam direction of current shot (unity direction vector)
    double beam_direction[3];
    //! (virtual) beam origin of current shot (unit is meter)
    double beam_origin[3];
    //! mirror facet of current shot
    unsigned facet;

    //! all targets belonging to the last laser shot
    std::vector<target> targets;
    typedef std::vector<target>::size_type target_count_type;
    //! the number of targets belonging to the last laser shot
    target_count_type target_count;

    // instrument descriptors
    std::string serial;  //!< scanner serial number
    std::string type_id; //!< scanner type
    std::string build;   //!< scanner build id

protected:

    //! callback when a laser shot is available, will be invoked
    //! even if no echoes are available for this shot
    virtual void on_shot();

    //! callback after all data belonging to a shot is available
    //! i.e. all echo packets (same as last echo)
    virtual void on_shot_end();

    //! callback when a complete laser point is available
    //! the point information is accesible from the targets member
    //!\param echo the classification of the last echo
    virtual void on_echo_transformed(echo_type echo);

    //! callback to indicate that at least two regular pps pulses have been seen
    //!\param none
    virtual void on_pps_synchronized();

    //! callback to indicate that pps pulses have stopped
    //!\param none
    virtual void on_pps_sync_lost();

    // overridden
    void on_header(const header<iterator_type>& h); //!< INTERNAL ONLY
    void on_units(const units<iterator_type>& arg); //!< INTERNAL ONLY
    void on_units_1(const units_1<iterator_type>& arg); //!< INTERNAL ONLY
    void on_units_2(const units_2<iterator_type>& arg); //!< INTERNAL ONLY
    void on_device_geometry(const device_geometry<iterator_type>& arg); //!< INTERNAL ONLY
    void on_pps_sync(const pps_sync<iterator_type>& arg); //!< INTERNAL ONLY
    void on_laser_shot(const laser_shot<iterator_type>& arg); //!< INTERNAL ONLY
    void on_laser_shot_1angle(const laser_shot_1angle<iterator_type>& arg); //!< INTERNAL ONLY
    void on_laser_shot_2angles(const laser_shot_2angles<iterator_type>& arg); //!< INTERNAL ONLY
    void on_laser_shot_2angles_rad(const laser_shot_2angles_rad<iterator_type>& arg); //!< INTERNAL ONLY
    void on_laser_shot_6angles(const laser_shot_6angles<iterator_type>& arg); //!< INTERNAL ONLY
    void on_laser_shot_2angles_hr(const laser_shot_2angles_hr<iterator_type>& arg); //!< INTERNAL ONLY
    void on_echo(const echo<iterator_type>& arg); //!< INTERNAL ONLY
    void on_laser_echo(const laser_echo<iterator_type>& arg); //!< INTERNAL ONLY
    void on_laser_echo_qual(const laser_echo_qual<iterator_type>& arg); //!< INTERNAL ONLY
    void on_laser_echo_sw(const laser_echo_sw<iterator_type>& arg); //!< INTERNAL ONLY
    void on_line_stop(const line_stop<iterator_type>& arg); //!< INTERNAL ONLY
    void on_frame_stop(const frame_stop<iterator_type>& arg); //!< INTERNAL ONLY
    void on_meas_stop(const meas_stop<iterator_type>& arg); //!< INTERNAL ONLY
    void on_nrange_table(const nrange_table<iterator_type>& arg); //!< INTERNAL ONLY
    void on_reftab_table(const reftab_table<iterator_type>& arg); //!< INTERNAL ONLY
    void on_atmosphere_2(const atmosphere_2<iterator_type>& arg); //!< INTERNAL ONLY
    void on_atmosphere_3(const atmosphere_3<iterator_type>& arg); //!< INTERNAL ONLY
    void on_mta_settings(const mta_settings<iterator_type>& arg); //!< INTERNAL ONLY
    void on_mta_settings_1(const mta_settings_1<iterator_type>& arg); //!< INTERNAL ONLY
    void on_dyntrig(const dyntrig<iterator_type>& arg); //!< INTERNAL ONLY
    void on_biaxial_geometry(const biaxial_geometry<iterator_type>& arg); //!< INTERNAL ONLY
    void on_notch_filter(const notch_filter<iterator_type>& arg); //!< INTERNAL ONLY

    std::ostream* out;
    bool header_written;
    //double system_time;     //!< INTERNAL ONLY

private:
    struct implementation;
    implementation* const priv;
    friend struct implementation;

    void init(); //!< INTERNAL ONLY
    void calc_shot_constants(); //!< INTERNAL ONLY
    void calc_origin_and_direction(); //!< INTERNAL ONLY
    void evaluate_shot(uint32_t systime); // !< INTERNAL ONLY
    void evaluate_shot_hr(uint64_t systime); // !< INTERNAL ONLY
    void send_first_or_interior(); //!< INTERNAL ONLY
    void send_single_or_last(); //!< INTERNAL ONLY

    void calc_time(uint32_t t); //!< INTERNAL ONLY
    void calc_time_hr(uint64_t t); //!< INTERNAL ONLY
    bool notched(int32_t range, uint16_t amplitude); //!< INTERNAL ONLY

    void update_pps(
        uint32_t t
        , uint32_t T
    ); //!< INTERNAL ONLY

    void pseudo_echo(
        double r
    ); //!< INTERNAL ONLY

    uint32_t pps_last; //!< INTERNAL ONLY

    // per instrument constants
    double range_unit; //!< INTERNAL ONLY
    double ppstime_unit; //!< INTERNAL ONLY
    double systime_unit; //!< INTERNAL ONLY
    double systime_hr_unit; //!< INTERNAL ONLY
    double ampl_unit; //!< INTERNAL ONLY
    double refl_unit; //!< INTERNAL ONLY
    unsigned line_circle_count; //!< INTERNAL ONLY
    int line_modul; //!< INTERNAL ONLY
    int line_offset; //!< INTERNAL ONLY
    double line_unit_half; //!< INTERNAL ONLY
    double frame_unit_half; //!< INTERNAL ONLY

    int is_biaxcorr; //!< INTERNAL ONLY
    double aperture_direction[3]; //!< INTERNAL ONLY
    double biax_range_step; //!< INTERNAL ONLY
    double biax_range_max; //!< INTERNAL ONLY
    std::vector<double> biax_shift; //!< INTERNAL ONLY
    double biax_q(double r); //!< INTERNAL_ONLY

    float notch_range_min; //!< INTERNAL ONLY
    float notch_range_max; //!< INTERNAL ONLY
    float notch_amplitude_max; //!< INTERNAL ONLY
    int32_t raw_notch_range_min; //!< INTERNAL ONLY
    int32_t raw_notch_range_max; //!< INTERNAL ONLY
    uint16_t raw_notch_amplitude_max; //!< INTERNAL ONLY
    //float notch_amplitude_to_rawamplitude; //!< INTERNAL ONLY
    //float notch_range_to_rawrange; //!< INTERNAL ONLY
    bool is_override_notch; //!< INTERNAL ONLY
    bool have_notch; //!< INTERNAL ONLY

protected:
    double a[4][3]; //!< INTERNAL ONLY
    double b[4][3]; //!< INTERNAL ONLY
    double c[4][3]; //!< INTERNAL ONLY
    double d[4]; //!< INTERNAL ONLY

    double l[3]; //!< INTERNAL ONLY
    double f[3]; //!< INTERNAL ONLY
    double O[3]; //!< INTERNAL ONLY

    double line_angle;
    double frame_angle;

    struct internal_shot_t {
        double cos_line;
        double sin_line;
        double cos_frame;
        double sin_frame;
        double s;
        double t;
        double n[3];
        double t1[3];
        double t2[3];
    } internal_shot;

    double biaxial_direction[3]; //!< INTERNAL ONLY

private:
    // per laser shot constants
    uint32_t line_angle_raw; //! < INTERNAL ONLY
    uint32_t frame_angle_raw; //!< INTERNAL_ONLY

    float background_radiation; //!< INTERNAL ONLY

    // per echo
    float deviation;//!< INTERNAL ONLY
    bool is_sw;//!< INTERNAL ONLY
    bool is_high_power;//!< INTERNAL ONLY
    bool is_rising_edge;//!< INTERNAL_ONLY

    // conversion from systime to pps time domain
    bool single_or_last_initialized; //!< INTERNAL ONLY
    detail::clock_compensator shot_clock; //!< INTERNAL ONLY

    // discard echoes we get before we have seen a shot
    bool shot_seen;

    // near range and reflactance tables
    float nrange_delta; //!< INTERNAL ONLY
    std::vector<float> nrange; //!< INTERNAL ONLY
    float refltab_delta; //!< INTERNAL ONLY
    std::vector<float> refltab; //!< INTERNAL ONLY

    bool is_override_mta; //!< INTERNAL ONLY
    bool have_mta_sensor; //!< INTERNAL ONLY
    unsigned mta_zone; //!< INTERNAL ONLY
    double rg_near; //!< INTERNAL ONLY
    double rg_far; //!< INTERNAL ONLY
    double unambiguous_range; //!< INTERNAL ONLY

    double v_group; //!< INTERNAL ONLY m/s
    double attenuation; //!< INTERNAL ONLY dB/m

    bool is_dyntrig; //!< INTERNAL ONLY
    float dyntrig_offset; //!< INTERNAL ONLY
    float dyntrig_scale;  //!< INTERNAL ONLY
    std::vector<float> dyntrig_thra1; //!< INTERNAL ONLY
    std::vector<float> dyntrig_del1; //!< INTERNAL ONLY
    std::vector<float> dyntrig_dec1; //!< INTERNAL ONLY
    std::vector<float> dyntrig_thra2; //!< INTERNAL ONLY
    std::vector<float> dyntrig_del2; //!< INTERNAL ONLY
    std::vector<float> dyntrig_dec2; //!< INTERNAL ONLY

    // not copyable
    pointcloud(const pointcloud&);

    int total_echo_count;
    int total_shot_count;
};

} // namespace scanlib

#endif // POINTCLOUD_HPP
